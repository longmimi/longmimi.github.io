{"meta":{"title":"LongTean's blog","subtitle":null,"description":"不患无位 患所以立","author":"LongTean","url":"http://longmimi.github.io","root":"/"},"pages":[{"title":"分类","date":"2017-03-25T14:34:41.000Z","updated":"2017-03-26T02:19:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://longmimi.github.io/categories/index.html","excerpt":"","text":""},{"title":"个人小天地","date":"2017-10-16T08:28:38.000Z","updated":"2017-12-29T08:05:26.000Z","comments":true,"path":"mysite/index.html","permalink":"http://longmimi.github.io/mysite/index.html","excerpt":"","text":"以下是一些个人小demo 打鼓效果Vue通讯录(F12查看效果)"},{"title":"标签","date":"2017-03-25T14:33:56.000Z","updated":"2017-03-25T14:35:42.000Z","comments":true,"path":"tags/index.html","permalink":"http://longmimi.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-15T03:51:41.559Z","updated":"2021-07-18T05:54:34.000Z","comments":true,"path":"about/index.html","permalink":"http://longmimi.github.io/about/index.html","excerpt":"","text":"关于我，请猛击这里"}],"posts":[{"title":"动手实现系列","slug":"手写系列","date":"2021-09-04T05:00:00.000Z","updated":"2021-09-04T06:12:15.958Z","comments":true,"path":"2021/09/04/手写系列/","link":"","permalink":"http://longmimi.github.io/2021/09/04/手写系列/","excerpt":"写一写，忘的慢。","text":"写一写，忘的慢。 防抖 debounce节流 throttle 防抖debounce防抖是将多次执行变为一次执行 触发高频事件后N秒内只会执行一次，若n秒内再次触发，则重新计算时间,短期内多次触发,只执行最后一次 思路：每次触发事件时都取消之前的延时调用方法 应用：页面滚动事件 12345678910111213141516171819function debounce(cb,delay,...args)&#123; let timeout = null; //存储定时器返回值 return (e) =&gt; &#123; if(timeout)&#123; clearTimeout(timeout);//每次触发就清除前一个定时器 &#125; timeout = setTimeou(()=&gt;&#123; //创建一个新的定时器，保证在时间间隔内fn不会执行 cb.apply(this,[e,...args]); clearTimeout(timeout); timeout = null; &#125;,delay) &#125;&#125;function success()&#123; console.log('防抖');&#125;ele.addEEventListener('input',debounce(success,500)); eg. 鼠标停止滚动500ms后执行回到函数fn 1window.onscroll = debounce(fn,500,args1,args2); 但是上面的实现存在一个问题，就是函数第一次触发需要等待一个时间间隔才会触发，针对这种情况 带有立即执行功能的防抖函数应运而生 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function now()&#123; return new Date();&#125;/* 防抖函数 返回函数连续调用时，必须时间间隔大于某一值，才会执行 * *@param &#123;function&#125; func 回调函数 *@param &#123;number&#125; wait 时间间隔 *@param &#123;boolean&#125; immedaite 是否立即调用函数*/function debounce(fn,wait=50,immdiate=true)&#123; let timer,context,args; //延时执行函数 const later = () =&gt; setTimeout(()=&gt;&#123; //延时函数执行完毕，清空缓存的定时器序号 timer = null //延时执行的情况下，函数会在延迟函数中执行 //使用到之前缓存的参数和上下文 if(!immdiate)&#123; func.apply(context,args) context = args = null; &#125; &#125;,wait) return function(...params)&#123; //如果没有创建延迟执行函数later，创建一个 if(!later)&#123; timer = later(); //如果是立即执行，调用函数 //否则缓存参数和上下文 if(immdiate)&#123; func.apply(context,args); &#125;else&#123; context = this; agrs = params; &#125; &#125;else&#123; //如果已经有延迟执行函数，调用时候清除原来的并重新设定一个 //此时延迟执行函数会重新计时 claerTimeout(timer); timer = later(); &#125; &#125;&#125; 节流throttle节流是将多次执行变为间隔执行 高频事件触发，n秒内只会执行一次，节流相当于稀释函数的执行频率 思路： 每次触发事件时都判断当前是否有等待执行的延时函数 利用时间戳判断执行间隔是否大于设置的时间间隔 1.设置时间戳 当触发事件的时候，拿到当前时间戳-之前的时间戳（最初为0）,如果大于时间间隔，那么就执行函数，然后更新时间戳为当前时间戳，否则不执行12345678910111213function throttle(func,wait)&#123; let context,args,previous=0; return function()&#123; let now = new Date(); context = this; args = arguments; if(now-previous&gt;wait)&#123; func.apply(context,args); previous = now; &#125; &#125;&#125; 2.使用定时器 当触发事件的时候，设置一个定时器，再出发事件的时候，如果定时器存在，则不执行，一直到定时器执行结束，执行函数之后清空定时器 123456789101112function throttle(func,wait)&#123; let timeout = null; return function()&#123; context = this; args = arguments; if(!timeout)&#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context,args); &#125;,wait) &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/tags/javascript/"}]},{"title":"垃圾回收","slug":"垃圾回收","date":"2021-07-17T06:00:00.000Z","updated":"2021-08-12T00:16:35.000Z","comments":true,"path":"2021/07/17/垃圾回收/","link":"","permalink":"http://longmimi.github.io/2021/07/17/垃圾回收/","excerpt":"垃圾回收机制（garbage collection）是指当js在创建变量时会自动分配内存，当这些变量不被引用时，将他们占用的内存释放掉，而没有及时将已经不需要的内存占用释放掉，就是内存泄漏。","text":"垃圾回收机制（garbage collection）是指当js在创建变量时会自动分配内存，当这些变量不被引用时，将他们占用的内存释放掉，而没有及时将已经不需要的内存占用释放掉，就是内存泄漏。 js常见会内存泄露有以下场景： 没有声明的变量赋值，被会绑定在全局对象上，即使不被使用也不会回收。 不清除定时器 闭包 事件监听未及时清除 js中变量分为 基础类型 和 引用类型。 基础类型在内存中占据固定大小的空间，因此保存在栈内存中；引用类型保存在堆内存中，堆内存的引用指针保存在栈中。 js 垃圾回收有以下策略： 标记清除 引用计数 标记清除这是js最常用的回收策略。分为 标记 和 清除 两个阶段。 当一个变量进入上下文中时会被加上标记 将所有在上下文中的变量以及上下文被访问引用的变量标记清除掉，表示这些变量是活跃的。 之后被加上标记的变量代表是准备删除的变量 执行内存清理，销毁这些变量回收内存 但是标记清除也有局限性： 由于从全局对象开始查找，那些无法从根对象查询到的变量都会被清除 会造成空间碎片化(将被清除的不可达对象释放到空闲链表的时候，由于中间有可达对象，因此空间不连续)，无法空间最大化使用，可以使用标记整理或者标记压缩算法进行内存整理 分配速度慢，由于空间碎片，需要对空闲链表遍历 标记整理标记整理可以看做对标记清除的增强，标记阶段一致，在清除阶段会先整理内存，移动对象位置，再清除，减少碎片化空间，但是缺点也是由于进行位置移动，回收效率慢。 引用计数对每个值记录引用的次数，当引用次数为0时，代表访问这个值，就会等待垃圾回收器回收。这种方式存在循环引用的问题无法清除的问题，所谓循环引用举个栗子就是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向A的指针，那么就无法清除，造成内存泄露。 V8中的分代回收v8引擎中垃圾回收机制基于分代回收机制，其将堆内存分为新生代、老生代、大对象空间、代码空间等等；新生代存储存活时间较短的对象，老生代是存活时间较长或者常驻内存的对象。 新生代占据堆较小的空间，垃圾回收频率较高，采用 复制算法+ 标记整理 回收， 基本就是 空间换时间 新生代内存分配两个等大小空间，使用空间From 空闲空间 To 活动（可达）对象存于From 中 当From空间使用到一定程度时触发回收操作： 整理可达对象和不可达对象，将所有不可达对象整理成连续空间，将可达对象复制到To，同时检查可达对象是否符合晋升条件，符合进入老生代空间 若无可达对象，直接清除 From 和 To交换，完成释放 晋升 晋升发生在从From 到 To的复制过程中 晋升条件 一轮清理后还存活的新生代对象晋升 To空间使用超过25%，则全部晋升 老生代大多为新生代存活一段时间转移至此，主要采用标记清除、标记整理、增量标记等。由于空间较大，空间换时间会造成空间浪费。 正常使用标记清除完成回收 老生代空间不足时 触发标记整理 增量标记进行效率优化 由于在垃圾回收时会停止应用逻辑，这种行为称为 全停顿 。因此将一段垃圾回收标记操作拆分成多个子标记操作，同时让垃圾回收标记和js应用逻辑交替进行，提高效率。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/tags/javascript/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://longmimi.github.io/tags/垃圾回收/"}]},{"title":"typescript学习","slug":"typescript学习","date":"2019-12-01T14:10:59.000Z","updated":"2021-08-12T00:19:04.000Z","comments":true,"path":"2019/12/01/typescript学习/","link":"","permalink":"http://longmimi.github.io/2019/12/01/typescript学习/","excerpt":"TypeScript是javascript的超集，为js添加了可选择的类型标注，增强了代码的可读性和可维护性。以下是通过官方文档和网上的学习资源，总结的ts学习笔记,加深记忆。","text":"TypeScript是javascript的超集，为js添加了可选择的类型标注，增强了代码的可读性和可维护性。以下是通过官方文档和网上的学习资源，总结的ts学习笔记,加深记忆。 基础类型接口泛型类类型推论函数枚举高级类型 基础类型安装npm install -g typescript 打开编辑器，新建demo.ts文件，输入1234567function tsFunc(person)&#123; return 'Hi' + person&#125;let user = \"longtean\";document.body.innerHTML = greeter(user); 接着打开命令行，输入 tsc demo.ts, 就可以将ts文件编译成js文件。 类型注解ts里的类型注解是一种轻量级的为函数或变量添加约束的方式。如果希望函数接受某种类型的参数，可以这么写：123function tsFunc(person: string)&#123; return 'Hi' + person&#125; 当你给这个函数传入了其他类型的参数并进行编译，就会报错提示传入的参数类型不符。同样，如果没有传递参数给函数，编译也会报错，提示传入非期望个数的参数。这是因为ts提供了静态的代码分析，可以分析代码结构和提供的类型注解。 基础类型ts支持与js几乎相同的数据类型，此外提供了 枚举类型 布尔值1let isDone : boolean = false 数字类型1let _number :number = 123; 字符串1let _string :string = 'longtean' 数组有两种方式可以定义数组123let _arraylist :number[] = [1,2,3]//或者使用数组泛型let list :Array&lt;number&gt; = [1,2,3] 元组Tuple元组类型表示一个已知元素数量和类型的数组，各元素的类型不必相同。123let x: [string, number]x = ['hello', 10]; // OK x = [10, 'hello']; // Error 枚举 enumenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 123456enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;//枚举类型的便利是可以由枚举的值得到名字。enum Color &#123; red=1,green,blue&#125;let colorName : string = Color[2]console.log(colorName) //green any123let value : any = 4;value =='aaaaa';value = false; void某种意义上说void和any相反 表示没有任何类型。只能被赋值 undefined 和 null null undefined是所有类型的子类型 never123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message)&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\")&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; object非原始类型，除 number，string，boolean，symbol，null或undefined 之外的类型 类型断言等于是告诉编译器，可以跳过类型判断 ，表明开发者了解当前类型 有两种形似。123//尖括号 语法let someValue : any = 'tetsas'let strLength : number = (&lt;string&gt;someValue).length 123// as 语法let someValue : any = 'sdjijfa'let strLength : number = (someValue as string).length 注 ： 在ts中使用jsx 只有as语法被允许 接口接口 interface我理解的接口就是类型注解的集合，用接口来描述一个对象的属性。在ts里，只要两个类型内部的接口可以兼容，那这两个类型就可以兼容。这就允许我们在实现接口的时候包含接口需要的结构就可以，不必实现所有的结构。123456789101112interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125;let user = &#123; firstName: \"Jane\", lastName: \"User\" &#125;;document.body.innerHTML = greeter(user); 可选属性接口里的属性不都是必须的。12345678910111213141516interface SquareConfig &#123; color?: string; width?: number&#125;function createSquare(config:SquareConfig) :&#123;color:string;area:number&#125;&#123; let newSquare = &#123; color: 'white',area:100&#125;; if(config.color)&#123; newSquare.color = config.color &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color:'blue'&#125;) 只读属性一些对象属性只能在对象刚刚创建时修改值， readonly 指定1234567// 赋值之后，就不能被修改interface Point&#123; readonly x:number; readonly y:numbet;&#125;let p1:Point = &#123;x:10,y:11&#125;;p1.x = 5 // error TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。12345678let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error!// ReadonlyArray赋值给普通数组也不行，可以使用类型断言重写a = ro as number[] 函数类型接口描述函数类型123interface searchFunc&#123; (source:string,subString:string) :boolean&#125; 可索引类型具有一个索引签名，描述对象索引的类型，和相应索引返回值类型123456interface StringArray&#123; [index:number]:string&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; ::: tip索引签名可以使用 字符串和数字，但数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象::: 类类型在接口中描述一个方法，在类里实现它. 继承接口接口和类一样 可以继承，从一个接口里复制成员到另一个接口里。12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型一个对象可以同时做为函数和对象使用，并带有额外的属性。1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 泛型先写一个普通的函数123function identity(arg: any): any &#123; return arg;&#125; any类型并不能保证传入的参数和返回类型是统一类型，这时候需要使用类型变量。1234567891011function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity : &lt;T&gt;(arg:T) =&gt; T = identity//使用不同泛型参数名let myIdentity : &lt;U&gt;(arg:U) =&gt; U = identity//使用带有调用签名的对象字面量来定义泛型函数let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 上面的这个函数，就叫做泛型，可以接受任意类型参数，但又可以约束参数和返回值类型。 有两种方法可以使用泛型函数。1234//传入所有的参数，明确指定T的类型let output = identity&lt;string&gt;(\"myString\");//使用类型推论，编译器会根据传入的参数推论T的类型let output = identity(\"myString\"); 泛型接口123456789interface genericIdentityFn &#123; &lt;T&gt;(arg:T) : T&#125;function identity&lt;T&gt;(arg:T) : T &#123; return arg;&#125;let myIdentity : genericIdentityFn = identity 泛型类123456class GenericNumber&lt;T&gt; &#123; value : T, func : ( x:T, y:T) =&gt; T&#125;let myGenericNumber = new GenericNumber&lt;number&gt;(); 泛型约束定义一个接口来约束泛型1234567891011interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;loggingIdentity(3); // error 数字没有.lengthloggingIdentity(&#123;length: 10, value: 3&#125;); 类类 classts支持基于类的面向对象编程，类和接口可以一起工作。新建一个带有构造函数和属性的 Student 类。123456789101112131415class Student&#123; fullName: string; constructor(public firstName, public middleInitial, public lastName) &#123; this.fullName = firstName + \" \" + middleInitial + \" \" + lastName; &#125;&#125;interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person : Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125;let user = new Student(\"Jane\", \"M.\", \"User\"); ::: tip注：在构造函数的参数上使用public等同于创建了同名的成员变量。::: 修饰符 public 默认 private 私有 类外不可访问 protected 在子类中仍可访问 readonly 必须在声明时或构造函数里被初始化 存储器ts可以通过getters/setters来截取对对象成员的访问，这是一个把类改写成get和set的例子。1234567891011class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; this._fullName = newName; &#125;&#125; 抽象类抽象类做为其它派生类的基类使用。使用abstract 关键字定义抽象类和抽象方法。不能创建一个抽象类的实例，但是允许创建一个对抽象类型的引用，也允许对一个抽象子类进行实例化和赋值123456789101112131415161718abstract class Department &#123; constructor(public name: string) &#123; &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 定义一个类，会创建一个类的实例和构造函数 把类当接口使用12345678class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 类型推论类型推论 interence类型是在哪里如何被推断的 1let X = 1 变量X会被推断为 数字类型。1let x = [0, 1, null]; 候选的类型有 数字和 null。 当候选类型不能推断出类型的时候，需要声明类型。1let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; ts也可以按照上下文环境进行类型推论：上下文归类。 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.button); //&lt;- Now, no error is given&#125;; 根据window.onmousedown的函数类型推论出右边函数表达式的类型。 函数函数 Function有两种方式可以创建函数12345678//函数声明function name(x:number,y:number):number&#123; return x+y&#125;//函数表达式let myName = function(x:number,y:number):number&#123; return x+y&#125; 函数必须指定返回值类型，包括void typescript里每个参数都是必须的，而js里每个参数都是可选的，不传就是undefined.在ts里可以在参数旁使用 ？实现可选参数。123456789101112131415161718192021222324252627282930//可选参数必须在必选参数的后面function name(name:string,type?:string)&#123; return name + type&#125;``` ### 重载函数根据传入不通的参数，返回不同类型的数据。ts查找重载列表和js相似，我们应该把最精确的定义放在参数第一个。# 枚举## 枚举 enumeratets支持数字和基于字符串的枚举。```js//后面的值被从1递增enum Direction &#123; Up = 1, Down, Left, Right&#125;enum Direction &#123; Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\",&#125; 枚举成员的值可以是常量 或者 计算 出来。 枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0 1enum E &#123; X &#125; //X 它不带有初始化器且它之前的枚举成员是一个 数字常量 1enum E &#123; A = 1, B, C &#125; 除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字 12345enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[a]; // \"A\" const 枚举 避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问1234const enum Enum &#123; A = 1, B = A * 2&#125; 高级类型高级类型 advanced高级类型交叉类型 &amp;是将多个类型合并为一个类型，就包含了所需要的所有类型特性。 12345678910111213class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;let result = new Person('fk') &amp; new ConsoleLogger('fu') 联合类型 |只能访问所有类型的共有成员 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 类型保护机制联合类型只能获取共有的成员，访问其他成员就会报错。当然我们可以添加类型断言来防止报错。 123456789101112131415161718let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125;//为了让这段代码工作，我们要使用类型断言：let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 可以通过类型保护来解决上面使用类型断言的问题。 要定义一个类型保护，只需定义一个函数，返回一个 类型谓词。格式： paramsName is type 12345678910111213141516171819function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125;if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125;//这段代码就变成了if (isFish(pet)) &#123; pet.swim(); //pet 是 Fish 类型&#125;else &#123; pet.fly(); // pet 不是Fish类型&#125; typeof 类型保护 有两种格式可以被识别被当做类型保护。 typeof v === ‘typename’ typeof v !== ‘typename’ 1234567 function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125; //等价于typeof x === 'number' instanceof 类型保护 1234567891011121314151617181920212223 class Foo &#123; foo = 123; common = '123';&#125;class Bar &#123; bar = 123; common = '123';&#125;function doStuff(arg: Foo | Bar) &#123; if (arg instanceof Foo) &#123; console.log(arg.foo); // ok console.log(arg.bar); // Error &#125; if (arg instanceof Bar) &#123; console.log(arg.foo); // Error console.log(arg.bar); // ok &#125;&#125;doStuff(new Foo());doStuff(new Bar()); inin 操作符可以安全的检查一个对象上是否存在一个属性，通常也被当做类型保护使用。 123456789101112131415interface A &#123; x: number&#125;interface B &#123; y: string &#125;funciton stuff(q: A | B)&#123; if( 'x' in A)&#123; //q:A &#125;else &#123; //q:B &#125;&#125; 可选参数和属性使用了 –strictNullChecks，可选参数会被自动地加上 | undefined: identifier!从 identifier的类型里去除了 null和 undefined 类型别名类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 泛型的类型别名 1234type Container&lt;T&gt; = &#123; value: T &#125;;//类型别名不能出现在 声明右侧的任何地方type Yikes = Array&lt;Yikes&gt;; // error 接口和类型别名接口创建了一个新的名字，可以在其他地方任意使用。类型别名只是对现有类型的引用，不创建新的名字。类型别名不能被 extends和 implements，因为你不能去修改一个现有的类型吧。 索引类型使用索引类型，编辑器就可以检查使用了动态属性名的代码。1234567891011121314funciton pluck&lt;T,K extends keyof T&gt;(o:T,names:K[]):T[K]&#123; return names.map(n=&gt;o[n])&#125;interface Person &#123; name: string; age: number&#125;let person :Person = &#123; name : 'long', age: 24&#125;let strings: string[] = pluck(person,['name']) //ok,string[] keyof T 是 索引类型查询操作符。 表示T上已知的公共属性名称的联合 1let personProps: keyof Person // 'name' | 'age' T[K] 索引访问操作符 通过索引访问到实例 映射类型从旧类型中创建新类型的一种方式：新类型以相同的形式去转换旧类型里每个属性。 1234567891011121314151617181920type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;// 使用type PersonPartial = Partial&lt;Person&gt;;type ReadonlyPerson = Readonly&lt;Person&gt;;type Keys = 'option1' | 'option2';type Flags = &#123; [K in Keys]: boolean &#125;;等同于type Flags = &#123; option1: boolean; option2: boolean;&#125;","categories":[{"name":"typescript","slug":"typescript","permalink":"http://longmimi.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://longmimi.github.io/tags/typescript/"}]},{"title":"webpack配置及优化","slug":"webpack配置及优化","date":"2019-07-23T14:52:06.000Z","updated":"2021-08-12T00:16:53.000Z","comments":true,"path":"2019/07/23/webpack配置及优化/","link":"","permalink":"http://longmimi.github.io/2019/07/23/webpack配置及优化/","excerpt":"安装本地安装1npm install webapck webpack-cli --save-dev","text":"安装本地安装1npm install webapck webpack-cli --save-dev 0 配置使用即默认配置，功能十分单一，会将src目录下的index.js文件打包到dist目录下，并命名为main.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// test.js 文件内容console.log('longtean')// index.js 文件内容const str = require('./test.js')console.log(str)//main.js打包后输出内容!(function(e) &#123; var t = &#123;&#125;; function n(r) &#123; if (t[r]) return t[r].exports; var o = (t[r] = &#123; i: r, l: !1, exports: &#123;&#125; &#125;); return e[r].call(o.exports, o, o.exports, n), (o.l = !0), o.exports; &#125; (n.m = e), (n.c = t), (n.d = function(e, t, r) &#123; n.o(e, t) || Object.defineProperty(e, t, &#123; enumerable: !0, get: r &#125;); &#125;), (n.r = function(e) &#123; \"undefined\" != typeof Symbol &amp;&amp; Symbol.toStringTag &amp;&amp; Object.defineProperty(e, Symbol.toStringTag, &#123; value: \"Module\" &#125;), Object.defineProperty(e, \"__esModule\", &#123; value: !0 &#125;); &#125;), (n.t = function(e, t) &#123; if ((1 &amp; t &amp;&amp; (e = n(e)), 8 &amp; t)) return e; if (4 &amp; t &amp;&amp; \"object\" == typeof e &amp;&amp; e &amp;&amp; e.__esModule) return e; var r = Object.create(null); if ( (n.r(r), Object.defineProperty(r, \"default\", &#123; enumerable: !0, value: e &#125;), 2 &amp; t &amp;&amp; \"string\" != typeof e) ) for (var o in e) n.d( r, o, function(t) &#123; return e[t]; &#125;.bind(null, o) ); return r; &#125;), (n.n = function(e) &#123; var t = e &amp;&amp; e.__esModule ? function() &#123; return e.default; &#125; : function() &#123; return e; &#125;; return n.d(t, \"a\", t), t; &#125;), (n.o = function(e, t) &#123; return Object.prototype.hasOwnProperty.call(e, t); &#125;), (n.p = \"\"), n((n.s = 0));&#125;)([ function(e, t, n) &#123; const r = n(1); console.log(r); &#125;, function(e, t) &#123; e.exports = \"longtean\"; &#125;]); 可以看到，由于使用了commonJS的模块化语法，而这个模块化语法无法运行在浏览器端，webpack在打包输出的文件里帮我们进行了处理，使得代码可以运行在浏览器端。 手动配置根目录新建配置文件 webpack.config.js 默认的配置文件名写法有两种，第二种是webpackfile.js,在运行webpack命令后，会执行node_modules下的webpack-cli/bin/config-yargs.js,defaultDescription属性中规定了默认配置文件名称 12345678910const path = require('path')module.exports = &#123; mode:'development', //模式 默认 production 和 development entry:'./src/index.js', //入口文件 output:&#123; filename:'bundle.[hash:8].js', //打包后的文件名 path: path.resolve(__dirname,'dist'), //路径必须是绝对路径 resolve()方法可以将相对路径解析为绝对路径 &#125;&#125; development模式打包出的bundle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 (function(modules) &#123; // webpackBootstrap // 模块缓存 var installedModules = &#123;&#125;; // 实现 require 方法 __webpack_require__ function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // define getter function for harmony exports __webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // define __esModule on exports __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require __webpack_require__.t = function(value, mode) &#123; if(mode &amp; 1) value = __webpack_require__(value); if(mode &amp; 8) return value; if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;); if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; // getDefaultExport function for compatibility with non-harmony modules __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module['default']; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, 'a', getter); return getter; &#125;; // Object.prototype.hasOwnProperty.call __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; // __webpack_public_path__ __webpack_require__.p = \"\"; // 加载入口模块 返回导出的对象 return __webpack_require__(__webpack_require__.s = \"./src/index.js\"); &#125;)/************************************************************************/ (&#123;/***/ \"./src/index.js\":/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//*! no static exports found *//***/ (function(module, exports, __webpack_require__) &#123;eval(\"const str = __webpack_require__(/*! ./test.js */ \\\"./src/test.js\\\")\\nconsole.log(str)\\n\\n//# sourceURL=webpack:///./src/index.js?\");/***/ &#125;),/***/ \"./src/test.js\":/*!*********************!*\\ !*** ./src/test.js ***! \\*********************//*! no static exports found *//***/ (function(module, exports) &#123;eval(\"module.exports = 'longtean test'\\n\\n//# sourceURL=webpack:///./src/test.js?\");/***/ &#125;) &#125;); 也可以指定配置文件名称 运行 webpack –config webpack.config.selfname.js 就可以以指定配置文件进行打包 或者package.json 文件中添加script脚本 123456//package.json&#123; \"scripts\": &#123; \"build\": \"webpack --config webpack.config.js\" //在这里进行配置 &#125;&#125; devServer安装本地开发服务器 1npm i webpack-dev-server -D 添加执行脚本123456//package.json&#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server\" &#125;&#125; 配置本地服务123456789//webpack.cpnfig.js devServer:&#123; //开发服务器配置 port:3001, progress:true, //是否显示进度条 contentBase: './dist', //以指定目录运行静态服务 open:true, //自动打开浏览器 compress:true //压缩 &#125; npm run dev 即可自动打开浏览器并访问3001端口 Html处理src目录下创建index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 需要安装 html-webpack-plugin插件 1npm i html-webpack-plugin -D 在配置文件中引入123456789101112131415161718//webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; ... plugins:[ //数组，放置左右webpack插件 new HtmlWebpackPlugin(&#123; template:'./src/index.html', //模板文件路径 filename:'index.html', //输出文件名 minify:&#123; removeAttributeQuotes:true, //删除双引号 collapseWhitespace:true //折叠空行 &#125;, hash:true //加hash &#125;) ]&#125; css处理src下创建index.css index.scss文件 123body&#123; background:#000;&#125; index.js中引入样式文件12require('./index.css')require('./index.scss') webpack并不能识别css代码，这时候需要安装loader来解析 安装 css-loader style-loader sass-loader node-sass1npm i css-loader style-loader sass-loader node-sass -D 在配置文件中添加module配置123456789101112131415161718192021222324252627282930313233343536module.exports=&#123; ... module:&#123;//模块 rules:[ //规则 css-loader 解析 @import //style-loader css插入head标签 //使用单个时loader名为字符串，多个loader时数组，需要配置参数options时对象 //loader执行顺序为自右向左 自下而上 &#123; test:/\\.css$/, use:[ &#123; loader:'style-loader', options:&#123; insertAt:'top' //style标签插入到顶部 &#125; &#125;, 'css-loader' ] &#125;, &#123; test:/\\.scss$/, use:[ &#123; loader:'style-loader', options:&#123; insertAt:'top' //style标签插入到顶部 &#125; &#125;, 'css-loader', 'sass-loader' // sass-loader 依赖node-sass 所以也得安装 ] &#125; ] &#125;&#125; npm run build 之后就会发现，css样式以style标签的形式，被插入在了head标签的顶部 如果想将css分离成独立的css文件，以link的形式引入，则需要用到mini-extract-plugin这个插件 修改配置文件1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports=&#123; plugins:[ ... new MiniCssExtractPlugin(&#123; filename:'main.css' &#125;) ], module:&#123; rules:[ &#123; test:/\\.css$/, use:[ //用MiniCssExtractPlugin.loader 代替 style-loader MiniCssExtractPlugin.loader, 'css-loader' ] &#125;, &#123; test:/\\.scss$/, use:[ MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader' ] &#125; ] &#125;&#125; build之后就会发现，打包出来的main.css以link形式被引入到了html文件中。 如果想给css自动添加前缀，则需要安装postcss-loader和autoprefixer这两个插件 123456789&#123; test:/\\.scss$/, use:[ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader' // sass-loader 依赖node-sass 所以也得安装 ]&#125; 需要给postcss添加一个配置文件才能使用postcss,根目录添加postcss.config.js 123module.exports = &#123; plugins:[require('autoprefixer')]&#125; 之前的js文件都是压缩的，想要css也压缩的话，需要使用插件optimize-css-assets-webpack-plugin 修改配置文件12345678910const OptimizeCss = require('optimize-css-assets-webpack-plugin')module.exports = &#123; optimization:&#123; //优化项 minimizer:[ new OptimizeCss() ] &#125;, ...&#125; 运行后发现，css被压缩，但是js却没有压缩，这是因为optimization.minimizer属性后js就默认不被压缩了，使用gulifyjs-webpack-plugin插件可以压缩js 安装之后修改配置文件 123456789101112131415const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; optimization:&#123; //优化项 minimizer:[ new OptimizeCssAssetsPlugin(), new UglifyJsPlugin(&#123; cache:true, parallel:true //支持同时压缩多个 &#125;) ] &#125;, mode:'production', //模式 默认 production 和 development ...&#125; 再次npm run build之后，文件都被压缩了 处理js1. 处理es6+在index.js中写一些es6的语法，在build之后发现打包出来的js仍旧使用ES6写法，为了兼容性，我们需要转化成ES5的写法，这时候需要安装babel 1npm i babel-loader @babel/core @babel/preset-env -D 修改配置文件1234567891011121314151617module.exports = &#123; ... module:&#123;//模块 rules:[&#123; test:/\\.js$/, use:&#123; loader:'babel-loader', options:&#123; presets:[ '@babel/preset-env' ] &#125; &#125; &#125; ] &#125;&#125; 之后npm run build之后就可以将es6代码转化成es5代码了 接下来往index.js增加12345class A&#123; a=1;&#125;let a = new A()console.log(a.a) npm run build之后发现提示需要安装@babel/plugin-proposal-class-properties插件，这是因为class属性目前处于提案中，所以babel通过单独插件的方式来支持编译。 安装这个插件之后修改配置文件123456789101112131415161718module.exports = &#123; ... module:&#123;//模块 rules:[&#123; test:/\\.js$/, use:&#123; loader:'babel-loader', options:&#123; presets:[ '@babel/preset-env' ]， &#125; &#125; &#125; ] &#125;&#125; 如果我们要使用装饰器模式的话，需要安装插件@babel/plugin-proposal-decorators 1234567891011@logclass A&#123; a = 1;&#125;let a = new A()console.log(a.a)function log(target)&#123; console.log(target)&#125; 修改配置文件 12345678910111213141516171819202122module.exports = &#123; ... module:&#123;//模块 rules:[&#123; test:/\\.js$/, use:&#123; loader:'babel-loader', options:&#123; presets:[ '@babel/preset-env' ]， plugins:[ //注意安装顺序 [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], '@babel/plugin-proposal-class-properties' ] &#125; &#125; &#125; ] &#125;&#125; 在test.js 写另外一个Class B，同时也写一些处理异步流程的Generator语法123456789class B&#123;&#125;function * gen(params)&#123; yield 1;&#125; console.log(gen().next()) 打包之后，发现虽然将ES6转化为了ES5的语法，但是gemerator这中内置api并没有转化，所以需要安装插件@babel/plugin-transform-runtime,以及在生产环境下注入一些脚本依赖的插件@babel/runtime，通过创建了一个helper方法将需要用到的公共方法抽离出来，避免了多个模块定义重复定义方法。 如果代码中存在一些实例上的方法，比如说数组的includes(),在编译的过程中是不会进行转化的，需要安装@babel/polyfill,因为需要在代码运行时使用，所以不能--save-dev来安装，插件会在Array的原型上重新实现个includes方法。 安装之后，修改配置文件 12345import \"@babel/polyfill\";module.exports = &#123; entry: [\"@babel/polyfill\", \"./src/index.js\"] &#125;; 通过在入口文件添加polyfill插件，为打包之后的代码插入在原有的JS内置对象及方法上做向后兼容的处理的代码。比如说ES5里面的 Object 是没有自带 assign 方法的，那么你加载了babel-polyfill 之后，它就给 Object 扩展了一个 assign 方法，这样你就可以直接使用 Object.assign(obj1, obj2) 了 2. 增加eslint添加eslint可以对我们的代码添加一些语法规范的校验 安装 npm i eslint eslint-loader -D 在配置文件中添加loader12345678910111213141516module.exports = &#123; ... module:&#123; rules:[ &#123; test:/\\.js$/, use:&#123; loader:'eslint-loader', options:&#123; enforce:pre //强制在最前面执行，最先执行的loader &#125; &#125; &#125; ] &#125;&#125; 可以在eslint官网根据自己的需求勾选不同的规则，最终生成.eslintrc.json文件放置在项目的根目录中。 全局变量引入暴露到全局对象上想要全局引用某个变量，需要用到expose-loader 1npm i expose-loader -D 在index.js中引入 jquery的 $ 并暴露给window对象 123import &apos;expose-loader?$!jquery&apos;console.log(window.$) npm run dev 之后控制台可以打印出$对象 也可以再webpack配置文件中添加 123456789&#123; ... rules:[ &#123; test:require.resolve('jquery'), //匹配模块中对jq的引用 use:'expose-loader?$' //暴露给全局的window.$ &#125; ]&#125; 这种方式需要在使用的文件中手动的import jquery,还有另外一种方式，可以将$注入到每个模块中这样我们就可以任意的使用$而不需要手动引入了 注入到每个模块需要使用到webpack的插件 在配置文件的plugin中添加123456const webpack = require('webpack')plugins: [ new webpack.ProvidePlugin(&#123; //在每个模块中都注入$ $:'jquery' &#125;)] 引入不打包如果我们通过import等引入了jq,但不希望webpack把这个库打包进bundle,js 就可以使用externals,在配置文件中添加 123456&#123; ... externals:&#123; jquery:'$' //引入$ 不打包 &#125;&#125; 这种方式就需要依赖运行环境包含$ 总结 1.expose-loader 暴露到window上 2.webpack.ProvideOlugin 注入到每个模块 3.引入不打包 图片处理在js中通过import或者require来引入图片，是一个字符串，并不能被webpack识别，需要使用file-loader来处理图片的路径 1npm i file-loader -D 在配置文件中添加123456789&#123; rules:[ &#123; test:/.\\(jpg,png,gif)$/, //css中引入的图片会被css-loader处理成require方式引入 use:'file-loader' &#125; ]&#125; 如果想要在HTML文件中引入图片，需要使用loader html-withimg-loader,解析出html中的图片引入 安装之后配置rules12345678&#123; rules:[ &#123; test:/\\.html$/, use:'html-withimg-loader' &#125; ]&#125; 开发中图片很多，一些比较小的图片可以转化成base64格式，从而减少http请求，需要用到url-loader 安装之后修改配置文件123456789101112131415161718&#123; rules:[ &#123; test: /\\.(png|jpg|gif)$/, // 当图片小于200k时转化为base64格式 // 大于则使用url-loader内置的file-loader处理 use: &#123; loader: 'url-loader', options: &#123; limit: 200*1024, outputPath:'/img/', PubilcPath:'https://daojia.jd.com' &#125; &#125; &#125; ]&#125; 打包多页应用之前的配置都是针对单页面应用，接下来配置多页面应用。 src下新建index.js 和 other.js两个文件 123456789101112131415161718192021222324252627const path = require('path')const HTMLWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode:'development', //多入口 entry:&#123; home:'./src/index.js', pther:'./src/other.js' &#125;, output:&#123; filename:'[name].[hash]js', path:path.resolve(__dirname,'dist') &#125;, //需要配置多个 HTMLWebpackPlugin chunks 表示页面的入口文件 plugins:[ new HTMLWebpackPlugin(&#123; template:'./src/index.html', filename:'home.html', chunks:['home'] &#125;), new HTMLWebpackPlugin(&#123; template:'./src/other.html', filename:'other.html', chunks:['other','home'] //写多个，会引用多个js &#125;) ]&#125; source-map打包之后，代码压缩成一行，如果代码有错误，我们很难在压缩后的代码中定位到错误，这个时候就需要通过webpack的devtool配置来进行源码的映射。 1234567module.exports = &#123; ... devtool:'source-map', //增加映射文件，方便调试源码，会生成一个sourcemap文件，显示错误的行和列 //devtool:'eval-source-map' 不会产生单独source-map 文件，集成在代码中 //devtool:'cheap-module-source-map' 产生单独的source-map 不会提示错误在第几行 //devtool:'cheap-module-eval-source-map' 不会产生文件，不提示列，只提示行&#125; watch 实时打包通过打开watch属性是实现时时打包,这样就可以真机调试了 123456789&#123; ... watch:true, watchOptions:&#123; poll:1000, 监控的间隔时间,一秒检查一次是否需要打包 aggregateTimeout:500 // 防抖，输入500毫秒后无输入再打包 ignore:/node_modules/ //不需要监控的文件 &#125;&#125; 这样每次都改之后都会自动重新打包 插件 CleanWebpackPlugin 作用是打包之前清空dist目录 12345678const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; ... plugins:[ new CleanWebpackPlugin('./dist') ]&#125; CopyWebpackPlugin 作用是打包时复制文件到打包的目录 12345678910const CopyWebpackPlugin = require('copy-webpack-plugin');module.exports = &#123; ... plugins:[ new CleanWebpackPlugin([ &#123; from:'./public',to:'./'&#125; //从哪拷贝到哪 ]) ]&#125; BannerPlugin (内置) 作用是给打包后的js和css文件头部添加注释 1new webpack.BannerPlugin('我是需要添加的注释') 跨域问题开发过程中都是localhost本地服务，就会遇到接口请求的跨域问题。 一、可以通过webpack配置devServer.proxy设置代理 123456789...proxy:&#123; 'api/':&#123; target:'baidu.com', //需要代理到的url pathRewrite:&#123; '/api':'' //将/api重写 &#125; &#125;&#125; 二、如果前端需要mock数据,可以利用webpack内置的express 服务器 123456789devServer:&#123; before(app)&#123; app.get('/api',(req,res)=&gt;&#123; res.json(&#123; xxx:xxx &#125;) &#125;) &#125;&#125; resolveresolve可以解析第三方的包 1234567891011121314module.exports = &#123; ... rules:[], resolve:&#123; modules:[path.resolve('node_modules')], //指定优先查找当前目录的node_modules alias:&#123; //配置别名 'bootstrap':'./dist/js/...' &#125;, extensions:['js','css','jsx','vue'], //按照这个顺序查找后缀的文件 mainFields:['main','style','css'], //引用的文件的主入口字段，对应packages.json mainFiles:['main'], //主入口文件的名字 默认是index &#125;&#125; 定义环境变量12345678&#123; plugins:[ new webpack.DefinePlugin(&#123; DEV: \"'dev'\", // JSON.stringify('dev') TAG:'true' //boolean 类型 &#125;) ]&#125; 区分不同环境可以将不同环境的配置文件分开写 webpack.dev.js webpack.base.js webpack.prod.js base写基础的配置，通过插件 webpack-merge 来合并到dev 和 prod 文件中 webpack.dev.js 1234567let &#123; smart &#125; = require('webpack-merge')let base = require('./webpack.base.js')module.exports = smart(base,&#123; mode:'development', // 其他配置&#125;) webpack.prod.js 1234567let &#123; smart &#125; = require('webpack-merge')let base = require('./webpack.base.js')module.exports = smart(base,&#123; mode:'production', // 其他配置&#125;) 修改project.json 中 脚本执行命令123456&#123; \"scripts\":&#123; \"dev\":\"webpack --config webpack.dev.js\", \"build\":\"webpack --config webpack.prod.js\" &#125;&#125; webpack优化 noParsewekpack的module有一个 noParse 属性，可以设置不解析引入库的依赖 12345module.exports = &#123; module:&#123; noParse:/jquery/ //不解析jquery的依赖 &#125;&#125; ignorePlugin这是webpack的内置插件，当项目中引入了库的时候，这些库还会引入其他一些库，可以通过这个插件将这些引入的库忽略，减小打包的体积。 例如引用monment这个库时，会引入很多语言包文件，这些对于我们来说并不需要，这些包都存放在./locale目录下 123456789const webpack = require('webpack')module.exports = &#123; ... plugins:[ //忽略 moment 引入的库 new webpack.IgnorePlugin(/./locale/,/moment/) ]&#125; dllPlugin通过提供分离包的方式来提升构建时间性能，使打包更快。其主要思想就是 将一些不做修改的依赖文件，提前打包，这样再发布前打包代码的时候就不需要对这部分代码进行打包。 在原来打包文件的基础上，新建一个webpack.dll.conf.js，webpack.dll.config.js作用是把所有的第三方库依赖打包到一个bundle的dll文件里面，还会生成一个名为 manifest.json文件，manifest.json的作用是用来让 DllReferencePlugin 映射到相关的依赖上去的 DllReferencePlugin 这个插件是在webpack.config.js中使用的，该插件的作用是把刚刚在webpack.dll.config.js中打包生成的dll文件引用到需要的预编译的依赖上来.就是说在webpack.dll.config.js中打包后比如会生成 vendor.dll.js文件和vendor-manifest.json文件，vendor.dll.js文件包含所有的第三方库文件，vendor-manifest.json文件会包含所有库代码的一个索引，当在使用webpack.config.js文件打包DllReferencePlugin插件的时候，会使用该DllReferencePlugin插件读取vendor-manifest.json文件，看看是否有该第三方库。vendor-manifest.json文件就是有一个第三方库的一个映射 只需要对这些第三方库打包一次，以后每次打包webpack.conf.js的时候，只需要打包项目的代码，当使用到第三方依赖的时候，会使用DllReferencePlugin 读取已经提前打包好的第三方库，从而提高打包速度，当第三方库有更新的时候，咋需要从新打包webpack.dll.conf.js webpack.dll.conf.js 123456789101112131415161718192021222324252627const path = require('path')const webpack = require('webpack')module.exports = &#123; entry:&#123; vender:[ 'react', 'react-dom', 'babel-polyfill' ] &#125;, output:&#123; filename:'[name].dll.js', path:path.resolve(__dirname,'dist'), library:'[name]_library' //可选，暴露出的全局变量名字 // 主要是给DllPlugin中的name使用， // 所以这里需要和webpack.DllPlugin中的`name: '[name]_library',`保持一致 &#125;, plugins:[ new webpack.DllPlugin(&#123; path: path.join(__dirname, 'dist', '[name]-manifest.json'), //生成上文说到清单文件，放在dist文件下面 name: '[name]_library' &#125;) ] &#125; webpack.conf.js 先安装add-asset-html-webpack-plugin这个插件，目的是给生成的vender.dll.js加上hash值,然后插入到htmk中去 12345678910111213141516const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin')module.exports = &#123; plugins:[ new webpack.DllReferencePlugin(&#123; context: path.resolve(__dirname, '..'), //manifest文件中请求的上下文 manifest: require('./dist/vendor-manifest.json') &#125;), //这个主要是将生成的vendor.dll.js文件加上hash值插入到页面中。 new AddAssetHtmlPlugin([&#123; filepath: path.resolve(__dirname,'../dist/js/vendor.dll.js'),\\ includeSourcemap: false, hash: true &#125;]), ]&#125; 最后，在package.json中配置运行命令12345&#123; \"scripts\":&#123; \"build:dll\": \"webpack --config webpack.dll.conf.js\" &#125;&#125; happypackhappypack 可以开启多线程打包，这对于比较大的项目，可以提高打包速度。 npm i happypack -D 123456789101112131415161718192021222324252627282930313233343536373839const happypack = require('happypack')module.exports = &#123; plugins:[ new happypack(&#123; id:'js', use:[&#123; loader:'babel-loader', options:&#123; preset:['@babel/preset-env'] &#125; &#125;] &#125;), new happypack(&#123; id:'css', use:[ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' ] &#125;)， ], module:&#123; rules: [ &#123; test: /\\.js$/, //js用happypack/loader多线程打包 use: 'happypack/loader?id=js', include: path.resolve(__dirname, 'src'), exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, //css用happypack/loader多线程打包 use: 'happypack/loader?id=css', include: path.resolve(__dirname, 'src'), exclude: /node_modules/ &#125;] &#125;&#125; 由于分配多线程也需要占用时间，因此在比较小的项目上效果不明显。 webpack自带优化tree-shaking通过import 语法引入的模块，在生产环境下，会自动去掉没用到的代码，这就是tree-shking,require不支持 Tree-Shaking性能优化实践-原理篇 Tree-Shaking性能优化实践 - 实践篇 Webpack4:Tree-shaking深度解析 scope hosting作用域提升，可以自动省略，可以简化的代码 Webpack 3 的新功能：Scope Hoisting splitChunks将公共部分代码单独抽离出来引用 理解webpack4.splitChunks webpack 4 Code Splitting 的 splitChunks 配置探索 懒加载通过 es6 的 import 语法动态的导入 需要引入的文件 需要安装插件 @babel/plugin-syntax-dynamic-import 123456789101112131415161718192021module.exports = &#123; module:&#123; rules:[ &#123; test:/\\.js$/， use:&#123; loader:'babel-loader', options:&#123; presets:[ '@babel/preset-env', '@babel/preset-react' ], plugins:[ '@babel/plugin-syntax-dynamic-import' ] &#125; &#125; &#125; ] &#125;&#125; 使用 1234import('./index.js').then(data=&gt;&#123; console.log(data.default) &#125;&#125;) 打包之后发现，webapck将动态引入的文件打包成了 1.js 热更新文件更新之后，不会刷新页面，起到部分刷新的作用 需要两个步骤： 使用 HotModuleReplacementPlugin 插件 打开 webpack-dev-server 的热更新开关 Webpack 的热更新，其实只是提供一套接口和基础的模块替换的实现。作为开发者，需要在代码中通过热更新接口（module.hot.xxx）向 Webpack 声明依赖模块和当前模块是否能够更新，以及更新的前后进行的处理。 如果接受更新，那么需要开发者自己来在模块被替换前清理或保留必要的数据、状态，并在模块被替换后恢复之前的数据、状态。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://longmimi.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://longmimi.github.io/tags/webpack/"}]},{"title":"jQuery使用总结","slug":"jQuery学习笔记","date":"2017-04-22T17:10:59.000Z","updated":"2021-08-12T00:16:45.000Z","comments":true,"path":"2017/04/23/jQuery学习笔记/","link":"","permalink":"http://longmimi.github.io/2017/04/23/jQuery学习笔记/","excerpt":"前言&emsp;&emsp;暑假的时候虽然说学习过一遍jQuery了，但只是眼过一遍，熟悉了基本的使用并没有做记录，趁着学校这两天学校运动会放假，决定整理一篇jQuery的笔记，方便以后复习,以上均通过w3school学习。","text":"前言&emsp;&emsp;暑假的时候虽然说学习过一遍jQuery了，但只是眼过一遍，熟悉了基本的使用并没有做记录，趁着学校这两天学校运动会放假，决定整理一篇jQuery的笔记，方便以后复习,以上均通过w3school学习。 课程章结jQuery介绍关键词：简介、安装、语法、选择器、事件、名称冲突 简介：jQuery是一个JavaScript函数库,它的宗旨是“write less，do more”,也就是一个轻量级的”写的少，做的多”的JavaScript库。 安装： 下载jQuery到本地，从本地载入 引用CDN中加载jQuery 使用以下代码可以加载CDN，使用引用CDN的方式有一个很大的优势就是许多用户在访问其他站点的时候已经加载过jQuery，结果就是当这些人访问站点时，会直接从缓存中加载jQuery，从而减少加载时间。而且，大多数CDN都可以确保用户在请求文件时，从最近的服务器上返回响应，从而提高加载速度；1234&lt;head&gt;&lt;script src=\"http://libs.baidu.com/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 语法： jQuery的基本语法是$(selector).action() 美元符号定义 jQuery 选择符（selector）”查询”和”查找” HTML 元素 action()函数 执行对元素的操作 为了防止文档在完全加载（就绪）之前运行 jQuery 代码，$(document).ready(function(){});将jQuery函数写在这个函数中 选择器 常见的选择器有以下几种： 元素选择器：$(&#39;p&#39;) id选择器：$(&#39;#id&#39;) .class选择器：$(&quot;.class&quot;) $(&#39;p.test&#39;)表示选择类别名为test的p标签 $(&quot;a[target=&#39;_blank&#39;]&quot;)：表示选取所有target属性值为_blank的a标签 更多可参考jquery选择器手册 事件 jQuery事件处理方法是jQuery的核心函数，事件处理程序指的是当HTML中发生某些事件所调用的方法，也叫作“触发”；（通常把jQuery代码放在部分的事件处理方法中；详细的事件参考jQuery事件手册 可以分为：鼠标事件（click），键盘事件(keypress)，表单事件(submit)，文档/窗口事件(load、scroll)等等 实例: $(this).hide() - 隐藏当前元素 $(&quot;p&quot;).hide() - 隐藏所有段落 $(&quot;p .test&quot;).hide() - 隐藏所有 class=”test” 的段落 $(&quot;#test&quot;).hide() - 隐藏所有 id=”test” 的元素 $(&#39;p&#39;).click(function(){});-点击p元素执行函数 名称冲突 由于其他库也可能使用$符号，那么就会引起冲突，jQuery中使用noConflict()方法来解决这个问题 注意事项 把所有的jQuery代码置于事件处理函数中； 把所有事件处理函数置于文档就绪事件处理器中； 把jQuery代码置于单独的.js文件中; 如果存在名称冲突，则重命名jQuery库； 示例 See the Pen jQuery1 by LongTean (@longtean) on CodePen. jquery效果关键词：隐藏显示、淡入淡出、滑动、动画、stop()、callback方法、chaining 显示隐藏 show(),hide(),比如隐藏的使用语法为：$(&#39;selector&#39;).hide(speed,callback),其中speed为速度，callback为完成隐藏动作后执行的函数，另外，toggle()可以显示和隐藏 淡入淡出 有fadeIn(),fadeToggle(),fadeTo(),使用语法同上，fadeTo(speed,opacity,callback)可以改变透明度。 滑动 slideDown(),slideToggle(speed，callback) 动画 animate()方法,使用语法为$(selector).animate({params},speed,callback);必需的 params 参数定义形成动画的 CSS 属性,可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒,可选的 callback 参数是动画完成后所执行的函数名称。 例:点击按钮，将div元素向右移动250px的同时，将透明度变为0.5且高度变为150px宽边为150px 12345678$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 需要注意的是css属性名必须像这么写：marginLeft。。。骆驼命名法吧 stop() 用来在动画或效果完成前对他们停止，使用语法$(selector).stop(stopAll,goToEnd);,其中可选参数stopAll规定是否应该清除动画队列，默认是false，即仅停止活动的动画，但允许队列中的其他动画执行；可选参数goToEnd表示是否立即完成当前动画，默认为false； callback() 此函数在当前动画100%完成之后执行；因为JS语句是逐一执行的，为了避免因为动画还没执行完成而造成动画与之后的语句之间可能产生的错误或者页面冲突，建议以参数的形式添加Callback函数； chaining* Chaining允许我们在一条语句中添加多个方法，例如`$(&apos;p&apos;).css(&apos;color&apos;, &apos;red&apos;).slideUp(2000).slideDown(2000);`，这是p元素就会先改变css样式，然后收缩，最后张开； 示例See the Pen jQuery2 by LongTean (@longtean) on CodePen. jquery HTML关键词：捕获、设置、添加、删除、css类、css()、尺寸 捕获 操作DOM的常用方法 text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 获取属性的方法 attr()- 用于获取属性值 设置 设置内容也是用上一节提到的三个函数，不过需要在括号中加入需要设置的内容； 同时需要知道，这三个jQuery方法都拥有回调函数，函数有两个参数，分别为被选元素列表中当前元素的下标以及原始值，text()、html() 以及 val() 的回调函数； 利用attr()来设置属性时可以同时设置多个属性，属性之间利用逗号隔开，此方法同样具有回调函数； 添加元素 利用jQuery可以很容易的添加新元素，具体有如下四个方法 append()- 在被选元素的结尾插入内容或元素 prepend()-在被选元素的开头插入内容或元素； after()-在被选元素之后插入内容或元素； before()-在被选元素之前插入内容或元素； append()和prepend()方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML，或者通过 JavaScript 代码和 DOM 元素。 注意：append()在一个元素的尾部添加内容，不添加新节点，而after是在被选元素之后添加内容，添加了新节点。 删除 删除元素和添加元素类似，有以下几个方法 remove() -删除被选元素及其子元素，括号中可添加选择器，用于删除符合选择器条件的元素及其子元素； empty()-从被选元素中删除子元素； css类 利用jQuery可以很容易的操作css元素，主要方法有 addClass()-向被选元素添加一个或多个类（添加多个类的时候类名称之间用空格隔开）； removeClass()-从被选元素删除一个或多个类； toggle()-对被选元素添加/删除类的切换操作； css() 设置或返回被选元素的一个或多个样式属性，语法为css(&#39;propertyName&#39;)如果有多个满足被选条件，则只返回第一个元素的属性； 如需设置CSS属性，则需使用语法为css(&#39;propertyName&#39;, &#39;value&#39;)，此时将所有满足条件的元素的样式都设置成目标样式； 尺寸 通过jQuery很容易处理元素和浏览器窗口的尺寸，主要的方法如下： width()-设置或返回元素的宽度（不包括内边距、边框和外边距），如果对象为document或者window，则表示返回HTML文档或者浏览器窗口的宽度和高度；如果在括号中加入数字，则表示将对应的尺寸设置为对应的值； height()-设置或返回元素的高度（不包括内边距、边框和外边距）； innerWidth()-返回元素的宽度（包括内边距）； innerHeight()-返回元素的高度（包括内边距）； outerWidth()-返回元素的宽度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的宽度； outerHeight()-返回元素的高度（包括内边距和边框），如果括号中增加参数‘true’则表示返回包括内外边距及边框的高度； 示例 See the Pen jQuery3 by LongTean (@longtean) on CodePen. jQuery遍历关键词：遍历、祖先、后代、同胞、过滤 遍历 遍历用于根据其相对于其他元素的关系来查找或者选取HTML元素； DOM遍历：遍历方法中最大的种类是树遍历tree-traversal 祖先 祖先元素包括父元素、祖父元素等等，常用的方法为： parent()-返回被选元素的直接父元素； parents()-返回被选元素的所有祖先元素，其中甚至包括文档的根元素； parentsUntil()-返回介于两个给定元素之间的祖先元素； 后代 与祖先相对的，后代指的是子、孙、曾孙等，常用的方法为： children()-返回被选元素的直接子元素； find()-返回被选元素的被find的元素，包括所有后代； 同胞 同胞拥有相同的父元素，常用的方法为： siblings()：返回所有被选元素的同胞元素； next()：返回被选元素的下一个同胞元素； nextAll()：返回被选元素的所有跟随的同胞元素； nextUntil()：返回介于两个给定参数之间的所有跟随的同胞元素； prev()：返回被选元素的上一个同胞元素； prevAll():返回被选元素的所有前面的同胞元素； prevUntil()：返回介于两个给定参数之间的所有的同胞元素； 过滤 缩小搜索元素的范围，常用的方位有以下几种： first()：返回被选元素的首个子元素； last()：返回被选元素的最后一个元素； eq()：返回被选元素中带有指定索引号的元素； filter()：返回符合匹配标准的元素集合； not()：返回不匹配标准的所有元素集合；jquery Ajax&emsp;AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。这一章我准备写一篇专门的博客来介绍，附上教程ajax教程. 总结&emsp;写了这么多，不仅是一种分享，希望更多地人看到，能对他们有所帮助，也是自己的一种总结，写在笔记本上的笔记会只属于自己，而写在这里的笔记，属于我们。&emsp;共勉","categories":[{"name":"笔记","slug":"笔记","permalink":"http://longmimi.github.io/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://longmimi.github.io/tags/笔记/"},{"name":"jquery","slug":"jquery","permalink":"http://longmimi.github.io/tags/jquery/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/categories/javascript/"},{"name":"typescript","slug":"typescript","permalink":"http://longmimi.github.io/categories/typescript/"},{"name":"webpack","slug":"webpack","permalink":"http://longmimi.github.io/categories/webpack/"},{"name":"笔记","slug":"笔记","permalink":"http://longmimi.github.io/categories/笔记/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://longmimi.github.io/tags/javascript/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://longmimi.github.io/tags/垃圾回收/"},{"name":"typescript","slug":"typescript","permalink":"http://longmimi.github.io/tags/typescript/"},{"name":"webpack","slug":"webpack","permalink":"http://longmimi.github.io/tags/webpack/"},{"name":"笔记","slug":"笔记","permalink":"http://longmimi.github.io/tags/笔记/"},{"name":"jquery","slug":"jquery","permalink":"http://longmimi.github.io/tags/jquery/"}]}